#!/usr/bin/env cs_python

import argparse
import json
import numpy as np
from cerebras.sdk.runtime.sdkruntimepybind import SdkRuntime, MemcpyDataType, MemcpyOrder # pylint: disable=no-name-in-module

# --- Main Script Execution ---
OUTPUT_FILE = "cerebras_results_summary.txt"
outfile = open(OUTPUT_FILE, 'w');

# Read command-line arguments
parser = argparse.ArgumentParser(description="Run Cerebras device program and compare results with simulation.")
parser.add_argument('--name', help="The test compile output directory.")
parser.add_argument('--cmaddr', help="IP:port for CS system.")
args = parser.parse_args()

# Get matrix dimensions (N and M) from the compile metadata file (out.json)
# This file is generated by the Cerebras compiler and contains information about the compiled program.
try:
    with open(f"{args.name}/out.json", encoding='utf-8') as json_file:
        compile_data = json.load(json_file)
    N = int(compile_data['params']['N']) # Column dimension
    M = int(compile_data['params']['M']) # Row dimension
except FileNotFoundError:
    print(f"Error: out.json not found in {args.name}. Please ensure compilation was successful.", file=outfile)
    exit(1)
except KeyError:
    print("Error: 'N' or 'M' parameters not found in out.json. Check your compile configuration.", file=outfile)
    exit(1)

# Construct a runner using SdkRuntime to interact with the Cerebras system
runner = SdkRuntime(args.name, cmaddr=args.cmaddr)

# Get symbols (memory addresses) for the data structures on the device
# These symbols allow the host to copy data to/from the device.
grid_symbol = runner.get_id('grid')


# Load and run the compiled program on the Cerebras system
runner.load()
runner.run()

# Define the PE grid dimensions. The loops below assume a 4x4 PE grid.
PE_GRID_X_DIM = 2
PE_GRID_Y_DIM = 2



# Dictionary to store results and original grid for summary
all_pe_results = {}
runner.launch('compute', nonblock=False)
# # Loop through each Processing Element (PE) in the 4x4 grid to retrieve and compare data
for pe_x in range(PE_GRID_X_DIM):
    for pe_y in range(PE_GRID_Y_DIM):
        print(f"\n{'='*20} PE({pe_x},{pe_y}) {'='*20}", file=outfile)

        # --- Retrieve and Print the PE's Own Grid Data ---
        device_grid_result = np.zeros([(M+2) * (N+2)], dtype=np.float32)
        runner.memcpy_d2h(device_grid_result, grid_symbol, pe_x, pe_y, 1, 1, ((M+2) * (N+2)), streaming=False,
                          order=MemcpyOrder.ROW_MAJOR, data_type=MemcpyDataType.MEMCPY_32BIT, nonblock=False)
        current_pe_grid_reshaped = device_grid_result.reshape(M+2, N+2)
        print("--- Device PE Grid Data ---", file=outfile)
        print(current_pe_grid_reshaped, file=outfile)
        print("-" * 25, file=outfile)

runner.stop()
print("SUCCESS!")
