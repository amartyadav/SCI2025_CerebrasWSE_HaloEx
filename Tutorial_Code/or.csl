param memcpy_params = comptime_struct;

// matrix dimensions
param M: i16;
param N: i16;

// color
param send_east_color: color;
param recv_west_color: color;

param send_west_color: color;
param recv_east_color: color;

param send_north_color: color;
param recv_south_color: color;

param send_south_color: color;
param recv_north_color: color;


// Queue IDs
const send_east_color_oq = @get_output_queue(2);
const recv_west_color_iq = @get_input_queue(2);

const send_west_color_oq = @get_output_queue(3);
const recv_east_color_iq = @get_input_queue(3);

const send_north_color_oq = @get_output_queue(4);
const recv_south_color_iq = @get_input_queue(4);

const send_south_color_oq = @get_output_queue(5);
const recv_north_color_iq = @get_input_queue(5);




// Task ID used by a local task to unblock cmd stream
const exit_task_id: local_task_id = @get_local_task_id(9);

const east_halo_exchange_ti: local_task_id = @get_local_task_id(10);
const west_halo_exchange_ti: local_task_id = @get_local_task_id(11);
const north_halo_exchange_ti: local_task_id = @get_local_task_id(12);
const south_halo_exchange_ti: local_task_id = @get_local_task_id(13);



const sys_mod = @import_module("<memcpy/memcpy>", memcpy_params);
const layout_module = @import_module("<layout>");
const simprint = @import_module("<simprint>");

var phase: u8 = 0;



// const a = 2;
// var subgrid: [4 * 4]f32;
// var subgrid_ptr: [*]f32 = &subgrid;

var grid: [M, N]f32;
var grid_ptr: [*]f32 = &grid;

var dest_arr_right = @zeros([M]f32);
var ptr_dest_arr_right: [*]f32 = &dest_arr_right;

var dest_arr_left = @zeros([M]f32);
var ptr_dest_arr_left: [*]f32 = &dest_arr_left;

var dest_arr_top = @zeros([N]f32);
var ptr_dest_arr_top: [*]f32 = &dest_arr_top;

var dest_arr_bottom = @zeros([N]f32);
var ptr_dest_arr_bottom: [*]f32 = &dest_arr_bottom;

fn init_grid() void {
    // PE coords
    const pe_x = layout_module.get_x_coord();
    const pe_y = layout_module.get_y_coord();
    simprint.fmt_with_coords("mod test ==={d}===", .{((pe_x+pe_y) % 2)});
    simprint.print_string("inside initgrid\n");

    var idx: u16 = 0;
    for (@range(u16, M)) |row| {
        for (@range(u16, N)) |col| {
            grid[row, col] = @as(f32, pe_x) * 1000.0 + @as(f32, pe_y) * 100.0 + @as(f32, idx);
            idx += 1;
        }
    }
}

fn send_right_col_east() void {
    const pe_x = layout_module.get_x_coord();
    const pe_y = layout_module.get_y_coord();
    
    // to be run by PE (0,0) and (1.0)
    simprint.print_string("in send_right_col_east\n");
    var right_col_dsd = @get_dsd(mem1d_dsd, .{
        .tensor_access = |i|{M} -> grid[i, N-1]
    });
    simprint.fmt_with_coords("PE({d},{d}) --- Sending right_col_east", .{pe_x, pe_y});
    var fabout_right_dsd = @get_dsd(fabout_dsd, .{ .extent = M, .fabric_color = send_east_color, .output_queue = send_east_color_oq });
    @fmovs(fabout_right_dsd, right_col_dsd, .{.async = true, .activate = exit_task_id });
}

fn recv_right_col_from_west() void {
    // to be run by 1,0 and 2,0
    const pe_x = layout_module.get_x_coord();
    const pe_y = layout_module.get_y_coord();
    simprint.print_string("in recv_right_col_from_west\n");
    
    
        simprint.fmt_with_coords("PE({d}, {d}) --- Receiving right column from west", .{pe_x, pe_y});
        var in_dsd = @get_dsd(fabin_dsd, .{ .extent = M, .fabric_color = recv_west_color, .input_queue = recv_west_color_iq });
        // var left_col_dsd = @get_dsd(mem1d_dsd, .{
        //     .tensor_access = |i|{M} -> grid[i, 0]
        // });
        
        var dest_dsd = @get_dsd(mem1d_dsd, .{
            .tensor_access = |i|{M} -> dest_arr_right[i]
        });
        @fmovs(dest_dsd, in_dsd, .{.async = true, .activate = exit_task_id });
        // @fadds(dest_dsd, in_dsd, left_col_dsd, .{.async = true, .activate = exit_task_id});
}

fn send_left_col_west() void {
    const pe_x = layout_module.get_x_coord();
    const pe_y = layout_module.get_y_coord();
    
    // to be run by PE (0,0) and (1.0)
    simprint.print_string("in send_left_col_west\n");
    var left_col_dsd = @get_dsd(mem1d_dsd, .{
        .tensor_access = |i|{M} -> grid[i, 0]
    });
    simprint.fmt_with_coords("PE({d},{d}) --- Sending left_col_west", .{pe_x, pe_y});
    var fabout_left_dsd = @get_dsd(fabout_dsd, .{ .extent = M, .fabric_color = send_west_color, .output_queue = send_west_color_oq });
    @fmovs(fabout_left_dsd, left_col_dsd, .{.async = true, .activate = exit_task_id });
}

fn recv_left_col_from_east() void {
    // to be run by 1,0 and 2,0
    const pe_x = layout_module.get_x_coord();
    const pe_y = layout_module.get_y_coord();
    simprint.print_string("in recv_left_col_from_east\n");
    
    
        simprint.fmt_with_coords("PE({d}, {d}) --- Receiving left column from east", .{pe_x, pe_y});
        var in_dsd = @get_dsd(fabin_dsd, .{ .extent = M, .fabric_color = recv_east_color, .input_queue = recv_east_color_iq });
        // var right_col_dsd = @get_dsd(mem1d_dsd, .{
        //     .tensor_access = |i|{M} -> grid[i, N - 1]
        // });
        
        var dest_dsd = @get_dsd(mem1d_dsd, .{
            .tensor_access = |i|{M} -> dest_arr_left[i]
        });
        @fmovs(dest_dsd, in_dsd, .{.async = true, .activate = exit_task_id });
        
        // @fadds(dest_dsd, in_dsd, right_col_dsd, .{.async = true, .activate = exit_task_id});
}

fn send_top_col_north() void {
    const pe_x = layout_module.get_x_coord();
    const pe_y = layout_module.get_y_coord();
    simprint.print_string("in send_top_col_north");
    var top_col_dsd = @get_dsd(mem1d_dsd, .{
        .tensor_access = |i|{N} -> grid[0, i]
    });
    
    simprint.fmt_with_coords("PE({d},{d}) --- Sending top_col_north", .{pe_x, pe_y});
    var fabout_top_dsd = @get_dsd(fabout_dsd, .{ .extent = N, .fabric_color = send_north_color, .output_queue = send_north_color_oq });
    @fmovs(fabout_top_dsd, top_col_dsd, .{.async = true, .activate = exit_task_id });
}

fn recv_top_col_from_south() void {
    const pe_x = layout_module.get_x_coord();
    const pe_y = layout_module.get_y_coord();
    simprint.print_string("in recv_top_col_from_south");
    simprint.fmt_with_coords("PE({d}, {d}) --- Receiving top column from south", .{pe_x, pe_y});
    var in_dsd = @get_dsd(fabin_dsd, .{ .extent = N, .fabric_color = recv_south_color, .input_queue = recv_south_color_iq });
    // var bottom_col_dsd = @get_dsd(mem1d_dsd, .{
    // .tensor_access = |i|{N} -> grid[M - 1, i]
    // });
    
    var dest_dsd = @get_dsd(mem1d_dsd, .{
        .tensor_access = |i|{N} -> dest_arr_top[i]
    });
    @fmovs(dest_dsd, in_dsd, .{.async = true, .activate = exit_task_id });
    // @fadds(dest_dsd, in_dsd, bottom_col_dsd, .{.async = true, .activate = exit_task_id});
}

fn send_bottom_col_south() void {
    const pe_x = layout_module.get_x_coord();
    const pe_y = layout_module.get_y_coord();
    simprint.print_string("in send_bottom_col_south");
    var bottom_col_dsd = @get_dsd(mem1d_dsd, .{
    .tensor_access = |i|{N} -> grid[M - 1, i]
    });
    
    simprint.fmt_with_coords("PE({d},{d}) --- Sending bottom_col_south", .{pe_x, pe_y});
    var fabout_bottom_dsd = @get_dsd(fabout_dsd, .{ .extent = N, .fabric_color = send_south_color, .output_queue = send_south_color_oq });
    @fmovs(fabout_bottom_dsd, bottom_col_dsd, .{.async = true, .activate = exit_task_id });
}

fn recv_bottom_col_from_north() void {
    const pe_x = layout_module.get_x_coord();
    const pe_y = layout_module.get_y_coord();
    simprint.print_string("in recv_bottom_col_from_north");
    simprint.fmt_with_coords("PE({d}, {d}) --- Receiving bottom column from north", .{pe_x, pe_y});
    var in_dsd = @get_dsd(fabin_dsd, .{ .extent = N, .fabric_color = recv_north_color, .input_queue = recv_north_color_iq });
    // var top_col_dsd = @get_dsd(mem1d_dsd, .{
    //     .tensor_access = |i|{N} -> grid[0, i]
    // });
    var dest_dsd = @get_dsd(mem1d_dsd, .{
        .tensor_access = |i|{N} -> dest_arr_bottom[i]
    });
    @fmovs(dest_dsd, in_dsd, .{.async = true, .activate = exit_task_id });
    // @fadds(dest_dsd, in_dsd, top_col_dsd, .{.async = true, .activate = exit_task_id});
}

task north_halo_exchange() void {
    send_top_col_north();
    recv_bottom_col_from_north();
    @unblock(south_halo_exchange_ti);
    @activate(south_halo_exchange_ti);
}

task south_halo_exchange() void {
    send_bottom_col_south();
    recv_top_col_from_south();
    @unblock(east_halo_exchange_ti);
    @activate(east_halo_exchange_ti);
}

task east_halo_exchange() void {
    send_right_col_east();
    recv_left_col_from_east();
    @unblock(west_halo_exchange_ti);
    @activate(west_halo_exchange_ti);
}

task west_halo_exchange() void {
    send_left_col_west();
    recv_right_col_from_west();
    @unblock(exit_task_id);
    @activate(exit_task_id);
}

fn compute() void {
    init_grid();
    simprint.print_string("++++inside compute++++\n");
    
    @activate(north_halo_exchange_ti);
    // send_right_col_east();
    // recv_right_col_from_west();
    
    // send_left_col_west();
    // recv_left_col_from_east();
    
    
    // send_top_col_north();
    // recv_top_col_from_south();
    
    // send_bottom_col_south();
    // recv_bottom_col_from_north();
    
}

task exit_task() void {
    simprint.print_string("inside exit_task\n");
    sys_mod.unblock_cmd_stream();
}

comptime {

    @initialize_queue(send_east_color_oq, .{ .color = send_east_color });
    @initialize_queue(recv_west_color_iq, .{ .color = recv_west_color });
    @initialize_queue(send_west_color_oq, .{ .color = send_west_color });
    @initialize_queue(recv_east_color_iq, .{ .color = recv_east_color });
    
    @initialize_queue(send_north_color_oq, .{ .color = send_north_color });
    @initialize_queue(recv_south_color_iq, .{ .color = recv_south_color });
    @initialize_queue(send_south_color_oq, .{ .color = send_south_color });
    @initialize_queue(recv_north_color_iq, .{ .color = recv_north_color });
    
    

    @bind_local_task(exit_task, exit_task_id);
    
    @bind_local_task(east_halo_exchange, east_halo_exchange_ti);
    @bind_local_task(west_halo_exchange, west_halo_exchange_ti);
    @bind_local_task(north_halo_exchange, north_halo_exchange_ti);
    @bind_local_task(south_halo_exchange, south_halo_exchange_ti);
    
    
    
    @block(south_halo_exchange_ti);
    @block(west_halo_exchange_ti);
    @block(east_halo_exchange_ti);
    @block(exit_task_id);
    
    @export_symbol(compute);
    
    @export_symbol(grid_ptr, "grid");
    @export_symbol(ptr_dest_arr_right, "ptr_dest_arr_right");
    @export_symbol(ptr_dest_arr_left, "ptr_dest_arr_left");
    @export_symbol(ptr_dest_arr_top, "ptr_dest_arr_top");
    @export_symbol(ptr_dest_arr_bottom, "ptr_dest_arr_bottom");
}





