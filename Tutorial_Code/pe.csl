param memcpy_params = comptime_struct;

// matrix dimensions
param M: i16;
param N: i16;

// Defining colors for all the 8 direction exchanges (2 exchanges in 4 directions each)
param send_east_color: color;
param recv_west_color: color;

param send_west_color: color;
param recv_east_color: color;

param send_north_color: color;
param recv_south_color: color;

param send_south_color: color;
param recv_north_color: color;

// Microthreads - Absolutely essential to implement this. Details in Appendix B. Added alrady for convenience.
// Need to reuse the limited input+output queue IDs.
const ut0 = @get_ut_id(0);
const ut1 = @get_ut_id(1);
const ut2 = @get_ut_id(2);
const ut3 = @get_ut_id(3);
const ut4 = @get_ut_id(4);
const ut5 = @get_ut_id(5);
const ut6 = @get_ut_id(6);
const ut7 = @get_ut_id(7);


// Queue IDs
// Notice how we are reusing queue IDs for Input & Output for 1 direction. Sending to East and Receiving from West uses the same route. 
// To be able to reuse the IDs, we need the Microthreads defined above. This is how we use different microthreads latest in the fabin and fabout operations.
// If we use different IDs (2,3,4,5,6,7...), we will run out due to the limited number of IDs available to us. 
// Cannot use reserved ID 1. We have 2,3,4,5,6,7. That does not cover all the directions we need.
const send_east_color_oq = @get_output_queue(2);
const recv_west_color_iq = @get_input_queue(2);

const send_west_color_oq = @get_output_queue(3);
const recv_east_color_iq = @get_input_queue(3);

const send_north_color_oq = @get_output_queue(4);
const recv_south_color_iq = @get_input_queue(4);

const send_south_color_oq = @get_output_queue(5);
const recv_north_color_iq = @get_input_queue(5);




// Task ID used by a local task to unblock cmd stream
// We are only using Local Tasks here. We need to assign Task IDs to each of our tasks. 

// TASK ID for the exit task, which allows us to end computation.
const exit_task_id: local_task_id = @get_local_task_id(9);

// TASK ID for the east halo exchange.
const east_halo_exchange_ti: local_task_id = @get_local_task_id(10);
// TASK ID for the west halo exchange.
const west_halo_exchange_ti: local_task_id = @get_local_task_id(11);
// TASK ID for the north halo exchange.
const north_halo_exchange_ti: local_task_id = @get_local_task_id(12);
// TASK ID for the south halo exchange.
const south_halo_exchange_ti: local_task_id = @get_local_task_id(13);

// TASK ID for the grid initialisation task.
const init_grid_ti: local_task_id = @get_local_task_id(14);



const sys_mod = @import_module("<memcpy/memcpy>", memcpy_params);
const layout_module = @import_module("<layout>");

const simprint = @import_module("<simprint>"); // Sort of like a print statement. Prints in the sim.log file. Only works on the simulator. 


// Declaring the grid to use. Size is [M+2, N+2] for the halo cells.
var grid: [M+2, N+2]f32;
var grid_ptr: [*]f32 = &grid;

// Calculate a unique identifier for this PE based on its coordinates.
// Assuming PEs are laid out row by row, starting from (0,0).
task init_grid() void {
    // PE coords
    const pe_x = layout_module.get_x_coord();
    const pe_y = layout_module.get_y_coord();

    const num_pes_x = 4;

    var pe_id: u16 = (pe_y * num_pes_x) + pe_x + 1; // +1 to start values from 1

    simprint.fmt_with_coords("-- pe_id -- {d}", .{ pe_id});

    // Fill the entire grid with the calculated pe_id
    for (@range(u16, 1, M + 1, 1)) |row| {
        for (@range(u16, 1, N + 1, 1)) |col| {
            simprint.fmt_with_coords("-- grid[{d}, {d}]:-- {d}", .{row, col, pe_id});
            grid[row, col] = @as(f32, pe_id);
        }
    }
    
    @unblock(east_halo_exchange_ti);
    @activate(east_halo_exchange_ti);
}


// The function names should be self explanatory here.

fn send_right_col_to_west_halo_of_east_neighbour() void {
    const pe_x = layout_module.get_x_coord();
    const pe_y = layout_module.get_y_coord();
    
    simprint.print_string("in send_right_col_to_west_halo_of_east_neighbour\n");

    // This is where we declare a 1D DSD to target the right most data column (not the halo) that needs to be sent to the west halo of the east neighbour.
    // Tensor access expression: |<induction-variable>| {<length>} -> <base-address>[<expr>]
    // Where:
    // induction-variable, a single identifier that represents the loop induction variable (its iteration variable).
    // length, a comptime-known non-negative integer expression that represents the number of times to iterate.
    // base-address, the name of a variable of tensor type or the name of a comptime-known variable of pointer-to-tensor type.
    // <expr>, a comma-separated list of affine expressions of the loop iteration variable and comptime-known values. 
    // There must be exactly as many affine expressions as the number of dimensions of the tensor that is specified by base-address.

 
    // .tensor_access = |i|{M+2} -> grid[i, N] ---> 'i' iterates from 0 to M+2, starting from grid[0,4], 
    // then capturing grid[1,4], grid[2,4], grid[3,4], grid[4,4], grid[5,4], grid[6,4]
    var right_col_dsd = @get_dsd(mem1d_dsd, .{
        .tensor_access = |i|{M+2} -> grid[i, N]
    });
    simprint.fmt_with_coords("PE({d},{d}) --- Sending right_col_east", .{pe_x, pe_y});

    // This is the Fabric Output DSD
    // Since we already defined and set the colors with directions and IO queues, we just need to name them below as parameters.
    var fabout_right_dsd = @get_dsd(fabout_dsd, .{ .extent = M+2, .fabric_color = send_east_color, .output_queue = send_east_color_oq });

    // This is a builtin. Refer to Appendix E. 
    // You basically 'move' your memory DSD (which holds your data now) into the fabric DSD which is set to be 'sent out' 
    // to the specific output queue using the specified color
    // .ut_id = microthread ID.
    @fmovs(fabout_right_dsd, right_col_dsd, .{.async = true, .ut_id = ut0});
}

// This is the equivalent Receive function for the above send call. 
fn recv_right_col_from_west_neighbour_in_west_halo() void {

    const pe_x = layout_module.get_x_coord();
    const pe_y = layout_module.get_y_coord();
    simprint.print_string("in recv_right_col_from_west_neighbour_in_west_halo\n");

    simprint.fmt_with_coords("PE({d}, {d}) --- Receiving right column from west", .{pe_x, pe_y});

    // Here, we declare an Fabric Input DSD first, to capture the incoming data. The extent should be the same as the extent above in the fabout DSD.
    // Mind the color and input queue here.
    var in_dsd = @get_dsd(fabin_dsd, .{ .extent = M+2, .fabric_color = recv_west_color, .input_queue = recv_west_color_iq });
    
    // We now target the west halo of this PE's data grid, where the incoming east halo needs to go.
    // We once again use the tensor access expression as above.
    var dest_dsd = @get_dsd(mem1d_dsd, .{
        .tensor_access = |i|{M+2} -> grid[i,0]
    });

    // You now 'move' your in_dsd which contains the incoming data into the memory DSD which points the your west halo of this PE. 
    // to the specific output queue using the specified color
    @fmovs(dest_dsd, in_dsd, .{.async = true, .ut_id = ut1});
}

// TODO: Complete the function below, following the same pattern as the above two corresponding send and receive functions.
// Keep in mind which rows and columns you target while defining the tensor access expressions.
fn send_left_col_to_east_halo_of_west_neighbour() void {
    const pe_x = layout_module.get_x_coord();
    const pe_y = layout_module.get_y_coord();
    
    simprint.print_string("in send_left_col_to_east_halo_of_west_neighbour\n");
    
    simprint.fmt_with_coords("PE({d},{d}) --- Sending left_col_west", .{pe_x, pe_y});
    
    // Add code below

    @fmovs(fabout_left_dsd, left_col_dsd, .{.async = true, .ut_id = ut2});
}

// TODO: Complete the function below
// Keep in mind which rows and columns you target while defining the tensor access expressions.
fn recv_left_col_from_east_neighbour_in_east_halo() void {
    const pe_x = layout_module.get_x_coord();
    const pe_y = layout_module.get_y_coord();
    simprint.print_string("in recv_left_col_from_east_neighbour_in_east_halo\n");

    simprint.fmt_with_coords("PE({d}, {d}) --- Receiving left column from east", .{pe_x, pe_y});
    
    // Add code below

    @fmovs(dest_dsd, in_dsd, .{.async = true, .activate = exit_task_id, .ut_id = ut3 });
}

// TODO: Complete the function below
// Keep in mind which rows and columns you target while defining the tensor access expressions.
fn send_top_row_to_south_halo_of_north_neighbour() void {
    const pe_x = layout_module.get_x_coord();
    const pe_y = layout_module.get_y_coord();
    simprint.print_string("in send_top_row_to_south_halo_of_north_neighbour");
 
    simprint.fmt_with_coords("PE({d},{d}) --- Sending top_row_north", .{pe_x, pe_y});

    // Add code below

    @fmovs(fabout_top_dsd, top_row, .{.async = true, .ut_id = ut4});
}

// TODO: Complete the function below
// Keep in mind which rows and columns you target while defining the tensor access expressions.
fn recv_top_row_from_south_neighbour_in_south_halo() void {
    const pe_x = layout_module.get_x_coord();
    const pe_y = layout_module.get_y_coord();
    simprint.print_string("in recv_top_row_from_south_neighbour_in_south_halo");
    simprint.fmt_with_coords("PE({d}, {d}) --- Receiving top column from south", .{pe_x, pe_y});
    
    // Add code below

    @fmovs(dest_dsd, in_dsd, .{.async = true, .ut_id = ut5 });
}


fn send_bottom_row_to_north_halo_of_south_neighbour() void {
    const pe_x = layout_module.get_x_coord();
    const pe_y = layout_module.get_y_coord();
    simprint.print_string("in send_bottom_row_to_north_halo_of_south_neighbour");
    
    simprint.fmt_with_coords("PE({d},{d}) --- Sending bottom_col_south", .{pe_x, pe_y});

    // Add code below

    @fmovs(fabout_bottom_dsd, bottom_col_dsd, .{.async = true, .ut_id = ut6 });
}

// TODO: Complete the function below
// Keep in mind which rows and columns you target while defining the tensor access expressions.
fn recv_bottom_row_from_north_neighbour_north_halo() void {
    const pe_x = layout_module.get_x_coord();
    const pe_y = layout_module.get_y_coord();
    simprint.print_string("in recv_bottom_row_from_north_neighbour_north_halo");
    simprint.fmt_with_coords("PE({d}, {d}) --- Receiving bottom column from north", .{pe_x, pe_y});
    
   // Add code below

    @fmovs(dest_dsd, in_dsd, .{.async = true, .ut_id = ut7});
}

// Defined below are tasks that we unblock and activate for each direction of the halo exchange.
// The names of the functions being called in each of the tasks should make it clear as to what
// part of the halo exchange is taking place on each tasks's activation.

// IMPORTANT: We cannot do a simultaneous exchange in all 4 directions, as this will lead to missed corner values, and innacurate data.
// This is why we wait for each direction to complete, and then within that direction's task, we activate the task for the next direction.
task east_halo_exchange() void {
    send_right_col_to_west_halo_of_east_neighbour();
    recv_right_col_from_west_neighbour_in_west_halo();
    // Unblocking south halo exchange task
    @unblock(south_halo_exchange_ti);
    @activate(south_halo_exchange_ti);
}

task south_halo_exchange() void {
    send_bottom_row_to_north_halo_of_south_neighbour();
    recv_bottom_row_from_north_neighbour_north_halo();
    
    // Unblocking west halo exchange task
    @unblock(west_halo_exchange_ti);
    @activate(west_halo_exchange_ti);
}

task west_halo_exchange() void {
    send_left_col_to_east_halo_of_west_neighbour();
    recv_left_col_from_east_neighbour_in_east_halo();
    
    // Unblocking north halo exchange task
    @unblock(north_halo_exchange_ti);
    @activate(north_halo_exchange_ti);
}

task north_halo_exchange() void {
    send_top_row_to_south_halo_of_north_neighbour();
    recv_top_row_from_south_neighbour_in_south_halo();

    // All exchanges complete at this point. Activating the exit task.
    @unblock(exit_task_id);
    @activate(exit_task_id);
}


// This is the main function which gets called from the host code. This activates the init_grid task, which then activates the halo_exchange tasks.
fn compute() void {
    simprint.print_string("++++inside compute++++\n");
    @activate(init_grid_ti);
}

task exit_task() void {
    simprint.print_string("inside exit_task\n");

    // Extremely important to unblock the command stream. Missing this leads to stalled kernel.
    sys_mod.unblock_cmd_stream();
}

comptime {

    // Each output queue needs to be initialised with a color.
    @initialize_queue(send_east_color_oq, .{ .color = send_east_color });
    @initialize_queue(recv_west_color_iq, .{ .color = recv_west_color });
    @initialize_queue(send_west_color_oq, .{ .color = send_west_color });
    @initialize_queue(recv_east_color_iq, .{ .color = recv_east_color });
    
    @initialize_queue(send_north_color_oq, .{ .color = send_north_color });
    @initialize_queue(recv_south_color_iq, .{ .color = recv_south_color });
    @initialize_queue(send_south_color_oq, .{ .color = send_south_color });
    @initialize_queue(recv_north_color_iq, .{ .color = recv_north_color });
    
    
    // All the local task IDs declared at the top need to be bound to their tasks.
    @bind_local_task(exit_task, exit_task_id);
    
    @bind_local_task(east_halo_exchange, east_halo_exchange_ti);
    @bind_local_task(west_halo_exchange, west_halo_exchange_ti);
    @bind_local_task(north_halo_exchange, north_halo_exchange_ti);
    @bind_local_task(south_halo_exchange, south_halo_exchange_ti);

    @bind_local_task(init_grid, init_grid_ti);
    
    
    // We block all the tasks except the init_grid and east_halo_exchange tasks. Those tasks unblock and activate the ones below.
    @block(south_halo_exchange_ti);
    @block(west_halo_exchange_ti);
    @block(north_halo_exchange_ti);
    @block(exit_task_id);
    
    // Exporting the 'compute' function to the host code to call.
    @export_symbol(compute);
    
    // Exporting the 'grid' to the host code to print and view the results of the grids after the exchange. Not elegant (or practical/possible)
    // to view the outut using the simprint library.
    @export_symbol(grid_ptr, "grid");
}